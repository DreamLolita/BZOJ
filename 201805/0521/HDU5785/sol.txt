首先如果我们求不重叠回文子串的对数那么
回文树中，num[now]表示添加该字符后新产生的回文串个数，即以该字符为结尾的回文串个数，num[now] = num[fail[now]]+1
正着跑一次，同时求出num的前缀和，再反着跑一次，同时累加prefixSum[i-1]*suffixSum[i]即可

这道题中则要求以该字符为结尾的回文串的起始坐标和，不方便直接维护和递推
后来想到，sum[now]表示以该字符为结尾的回文串长度和，则sum[now] = sum[fail[now]] + len[now]
则 (pos[now]+1)*num[now] - sum[now] 即是起始坐标和，反着跑时也可以类似的求出终止坐标和，相乘累加即可

总是在不可名状的地方爆了long long