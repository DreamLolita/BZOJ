转化一下问题，发现如果我们预处理每个点到根的异或和，这样询问就变成了路径上任意两点的异或的和。
这个东西可以通过维护某一位是1的有多少个来分别统计贡献。
当然如果我们先放到序列上考虑问题,就是GDKOI2016魔卡少女。
那题是询问一个区间的子区间异或和。方法是拆开二进制的每一位，然后用线段树维护异或前缀和中0，1的个数，个数相乘后再加权即为答案。
这样正确的原因是：对于一个有贡献的区间[L,R]，它一定会被sum[L-1]和sum[R]算到且仅一次。

而修改操作等价于每颗线段树的最多log个区间翻转之类的。
于是我们树剖+拆多颗线段树就可以了。

