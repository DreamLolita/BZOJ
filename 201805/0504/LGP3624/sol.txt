这题愣是看了INF的时长才看懂。
其实就是求长度为m的其中一部分已经给定字符串中，能划分为k个不下降串的字典序第r大的字符串。
然后长得就很像数位dp。
首先倒着dp，f(i,j,k)表示第i个位置，填j这个字符，最少划分成k段不下降子串的方案数
做完这个dp了之后将f(i,j,k)累加到f(i,j,k+1)，因为最少划分成k段的一定满足至少能划分成k+1段
然后再正着统计答案，维护当前填好的字符串最少划分成了几个不降子串now，枚举下一位i需要填的字符j，如果字符j大于或等于上一位填的字符，那么后面的至少划分成K-now+1段就可以，否则必须至少划分成K-now段
判断f(i,j,K-now+?)和R的关系，如果小，说明这一位就填当前这个字符，否则用R-f，然后枚举下一个字符
感觉这是处理字符串字典序问题的常用方法