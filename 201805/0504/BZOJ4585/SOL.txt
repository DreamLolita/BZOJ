APIO的题真是太妙了啊！

首先我们设f(i,x)为点i在它所有叶子节点深度为x时的最小代价，
我们可以发现这是一个下凸函数，而且是一次的，而且相邻两端斜率变化为1.
显然在斜率为0的时候取到最优值，所以对于每个点，实际上我们要做的就是合并它的所有儿子的凸包。
设取到最小值的区间为$[L,R]$，然后我们有下面这个东西。
$$H'(x) =\left\{ \begin{array}{ll}H(x)+w&x\le L\\H(L)+w-(x-L) & L\le x\le L+w\\H(L) & L+w\le x\le R+w\\H(L)+(x-R)-w & R+w\le x  \end{array}\right$$
想到这的时候我个人发现很不可做，因为插进来一堆点，节点数会很多。
后来想到splay合并是log^2,，启发式合并也是log^2，但是启发式合并顺序的splay是log的。
然后就感觉异常难打，sc大佬勇敢地开始打了，而我还在思索。

当天晚上我又在研究这个凸包的性质，思考能不能用简单的数据结构维护凸包。
看到上面的合并凸包实际上只会改变最优值左边的凸包，因此最优值右边的凸包是没用的。
又发现实际上我们并不需要知道凸包的实际形态，只需要记住每个折点的位置，我们就能知道整个函数/
接着问题就在于怎么维护这些折点位置。
我们发现我们合并凸包的时候，我们一定是将两个最右端斜率为0的点进行合并，两个凸包的合并，其实等价于将斜率为-1,0,1的三段插入凸包。
插入以后会怎么样呢？我们发现凸包最右边的斜率最多为1。那么一个节点的所有子节点的凸包合起来，它的凸包最右边的斜率最多就是(子节点个数)
这样我们就可以简单地用一个堆来维护凸包的折点了！
简单来说，就是将所有凸包合并上去父节点，弹出右边(子节点个数)的节点，然后父节点再添加两个节点。

最后取出所有1节点上所有的点，然后依次减掉就行了。

wxh：
$f(0)=\sum$ 树边权，然后斜率每次-1直到0
那么从右往左减就可以了
$sum-=p[i]$可以理解为把$p[i]$的斜率=-1的贡献算进去，然后前面所有直线斜率-=1
