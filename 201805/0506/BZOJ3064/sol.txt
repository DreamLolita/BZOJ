首先我们回想一下单点历史最值怎么做？
我们可以设计一个标记(a,b)，表示对于当前区间，所有数要先加上a然后与b取max

这样每个线段树节点维护四个标记：a,b,maxa,maxb，(a,b)表示对子树内的所有数执行x′=max(x+a,b)，maxa,maxb是历史最大标记，初始时a=ma=0,b=mb=-INF
首先是更新标记，假如有新标记a′,b′,maxa′,maxb′
要加到原有标记上，因为x′=max(max(x+a,b)+a′,b′)=max(x+a+a′,max(b+a′,b′))，所以我们用a+ma′更新ma，用max(b+ma′,mb′)更新mb，用max(b+a′,b′)更新b，用max(a+a′,-INF)更新a

操作1
就是(x,0,x,0)，操作2就是(-x,0,-x,0)，操作3就是(-INF,x,-INF,x)（因为这里的标记是a=ma=-INF，所以刚才更新a要和-INF取max防止爆long long），两个询问直接pushdown下去即可
存历史最大标记而不是历史最大值是因为有可能一个标记还未被传下去用于更新实际数值就被另一个标记覆盖了，所以要存标记的历史最大值

那么区间最值可以用类似的方法来做。
所以自己YY。

需要维护的值有6个：当前最大值，当前的加法标记，当前的覆盖标记；历史最大值，历史最大的加法标记，历史最大的覆盖标记
其实说历史最大的加法和覆盖标记并不是那么准确，更准确地说应该是 现在能用来更新子树的最大值
维护当前的一系列量都比较好写，都是线段树的基本操作
但是维护历史的一系列量更新就比较麻烦了，首先要知道的是维护历史的量一定分别对应大于等于维护当前的量，具体地：
更新子树的历史最大值：考虑这个区间的历史加法和历史覆盖，以及子树的当前最大值
更新子树的历史加法：考虑这个区间的历史加法和子树的当前加法
更新子树的历史覆盖：考虑这个区间的当前覆盖和子树的历史覆盖
值得注意的是如果子树当前没有覆盖，那么可以直接更新加法，否则应该把加法加到覆盖上
还有，每到一层区间就直接下放标记，无论区间是否完全覆盖
