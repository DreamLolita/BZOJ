首先，k=1的时候 即找出树的直径即可。

难点在k=2的时候

第一条边肯定是连直径，那么第二条边怎么连？

因为要求必须经过新连的边，所以有一些本来只需要经过一次的边，在连了第二条边之后就必须再走一次，我们称该事件为事件A。

我们画图得出如下结论

设我们选的第二条边的两个端点分别为 s,t

如果 s,t均 不在直径上任意一点（除1外)的子树内 则不会出现事件A

如果s或t在直径上任意一点（除1外)的子树内 则会出现事件A

我们直接去考虑s和t均在直径的子树中的情况：

画图可知，第二条边连后 要重复经过的边有两种选择

第一种是s到t的那条链

第二种是s往下走，经过新连的第一条边，再往上走，从而到达t

对于第一种情况，我们可以将直径上的边赋上权值 -1，其他边权值为1 然后找出此时树的直径即可。

对于第二种情况，又该如何做呢

我们不可能连边后对图跑dp，这是很难做的，也不可能断边。那我们该怎么办呢？

我们发现，如果s和t是按照第二种情况走的，

那么我们会损失 s到直径顶端的长度+t到直径的另一顶端的长度+1的收益，

获得 s的子树（不包括直径所在子树）中最长链长度+t的子树（不包括直径所在子树）中最长链长度

突然，我们发现一个事情： 因为s和t是在直径上的点，所以

s到直径顶端的长度>=s的子树（不包括直径所在子树）中最长链长度

t到直径顶端的长度>=t的子树（不包括直径所在子树）中最长链长度

这是直径的性质，无需在此证明了。

所以我们发现，这样的话收益是负的！还不如连个自环！

所以，情况二无需考虑！

那么问题就圆满地解决了。

题解做法：

1.找出树的直径

2.将直径上的边赋值为-1，其他边为1，再找直径