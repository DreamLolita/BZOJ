考虑动态树分治。我们对于每个点（点分树）维护两个树状数组。两个树状数组都以距离为下标，权值为内容。第一个树状数组维护子树中距离该点为k的权值和，第二个维护距离该点父亲距离为k的权值和。这样改权值时我们暴力爬树高，loglog复杂度（log的树高加上log的树状数组）。查询的时候一样爬树高，要注意容斥（把当前子树k的先加起来，往祖先上爬，如果距离小于k，假设为d，我们到祖先上去求一个k-d，再容斥掉原来这棵子树里被计算过的，这就是第二个树状数组的用处）。