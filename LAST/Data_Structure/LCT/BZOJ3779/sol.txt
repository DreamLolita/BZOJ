实际上，如果你把release看成access，recenter看成makeroot，这tm就是一个LCT。
答案是什么？每个点的感染时间就是该点到根路径上虚边的个数。

所以只需要在access的时候维护子树的点权和即可。这个可以用DFS序+树状数组区间修改区间查询。
不过有换根操作如何处理子树呢？去做遥远的国度那题吧。大概就是分类讨论。
利用dfs序的性质，设新的根为root，当前查询节点为$u$，那么$u$与$root$存在三种关系。
1.$x=root$，查询整棵树
2.$root$不在x的子树内，直接查询以1为根时$x$的子树即可
3.$root$在x的子树内，设$p$为$x$的亲儿子中包含$root$的节点，那么需要查询的就是整棵树去除掉p这棵子树的结果得到的答案了。

需要注意的是“代表的子树”这个东西，需要记录一棵splay中最左和最右的节点分别是谁。

注意：splay中的子树与原树中的子树并不相同。
所以在access中修改子树信息时，并不是$modify(tr.ch[x][1])$，
而是在tr.ch[x][1]的子树中找到深度最小的那个点，并modify那个点。
并且为了平衡，我们需要再将那个点splay一下。