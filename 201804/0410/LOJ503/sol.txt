两维之间是互不相关的，我们可以把每一维分开处理。
对于一维向量数组a[1..n]，对其求前缀和，设为s[1..n]，那么我们就是要求有多少个1<i<=n满足s[i-1]*s[i]<0，同时要支持从指针now开始的后缀同时加上一个数。
由于是后缀同时加上一个数，不难想到可以打标记，设tag表示now开始的每个数都要加上tag。
同时记录一个当前的答案ans，考虑在修改操作时如何维护答案。
由于修改的只有从now开始的后缀，所以只考虑这部分贡献的改变量。
改变量=新的贡献-之前的贡献。
之前的贡献就是要求有多少个now<i<=n满足min(s[i],s[i-1])<-tag且max(s[i],s[i-1])>-tag。
把[min(s[i-1],s[i]),max(s[i-1],s[i])]看作一个区间，那么要求的就是有多少个区间经过tag这个点。
设修改量为delta，同理新的贡献就等于有多少个区间经过-tag-delta这个点。
不难发现这样的话我们要做的就只有维护：加入一个区间，删除一个区间，查询一个点被多少个区间经过。
直接上线段树即可。