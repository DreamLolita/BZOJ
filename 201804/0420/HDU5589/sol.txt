HDU5589
这题很巧妙，看数据知道要用莫队，不过如何来处理树上任意两点的边权异或和大于m呢？
我们知道，一个数和另一个数异或两次等于自己，

如果我们记录所有的点都与1这个点的路径异或和，不就可以得出任意两点的路径异或和了吗，
然后如果我们要用莫队，就要找到增加，删除的时候答案对应的变化，要支持增加删除，并且要找比m大的异或值，
01字典树是一个不错的选择，我们考虑如果要找比m大的数，那么在二进制下，前面的位肯定都相同，后面的某一位m为0，当前数为1才有比m大，
我们在将异或和插入字典树的时候，转换为二进制，从高位开始插，每插一位，当前的cnt++，表示在当前位为0或者1的数有一个，删除的时候就对应cnt--就行了。

询问：这里设即将插入的数为节点x到1的节点的异或值为sum，我们要和m相比，因为要找比m大的数，
而我们此时插入的都是当前节点到根节点的异或和，这里我们就要用到贪心的思想，从高位开始找，
当m的当前位为1时，此时你只能找字典树中为与sum当前位异或为1的，如果不找与sum当前位异或为1的那你后面的位无论怎么找，都不能大于m，
要与sum当前位异或为1,当sum的当前位为0，应找1这个子节点，当sum当前位为1，应找0这个子节点，
所以就是当m的当前位为1时，下一个子节点应为（sum的当前位^1），当m的当前位为0时，直接加上与sum当前位异或为1的子节点的cnt，
因为到这一位的时候，与sum当前位异或为1,那后面位与sum异或完后必然是大于m的，所以直接加上当前与sum异或为1的子节点的cnt就行了，
然后我们继续搜寻与sum当前为异或为0的下一位，和上面一样，要使与sum当前位异或为0，sum当前位^0=sum当前位。

最后莫队处理完就是结果了