模板练习――dijkstra

注意到当我们走出第一步后，题目便转换为求最短路，而在计算每个点返回原点时存在大量的重复计算。
先求出从原点出发到达每个点的最短距离d[i]， 记录该路径从原点出发到达的第一个点p[i]
创建虚拟汇点T，构建新图

依次枚举原图所有边
1： 该边为(u,1,w) ，即从u点连向原点的边
若 u != p[u] 说明从原点到达点u的最短路径中没有经过边(1,u)，
即边(u,1)可以被使用，此时存在一条原点S -> p[u] -> … -> u -> S 的路径
在新图中直接创建一条 (S,T, d[u]+w)的边
若u == p[u] 说明到达点u的最短路径是由边(1,u)得到，所以不能通过d[u]+w的方式返回原点。
但如果存在其他方式到达点u,则可以通过该边返回，故在新图中创建边(u,T,w)
 
2： 该边为(1,v,w) 即该边为从原点出发的边
若p[v]=v，即说明原点到达点v的最短路径即为(1,v,w)，故此时不再添加边
若p[v]!=v,说明原点到达点v的最短路径不是(1,v,w)，此时需要在新图中添加边(1,v,w)

3： 该边为(u,v,w)   (u != 1 && v != 1)
若p[u] != p[v]，说明从原点到达点u的最短路径，与从原点到达点v的最短路径不同，
即存在S -> p[u] -> u -> v 的路径，创建边(1,v,d[u]+w)
若p[u] == p[v]，则在新图中保留原边 (u,v,w)

然后在新图中求一次从S到T的最短路

ans = d[T]