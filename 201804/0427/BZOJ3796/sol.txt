对s_1和s_2建立后缀数组，枚举s_1的每个后缀，该后缀与在后缀数组离它最近的s_2的某个后缀的最长公共前缀长度为在满足前两个条件下的最大答案。
对于条件 3对s_3建立AC自动机，求出s_3在s_1中的每个匹配位置，设每个i位置的右边第一个匹配 s_3的位置为r(i)，则在满足条件三的情况下，第i个后缀的最大答案为 r(i)-i+len(s3)-1 \
将两个答案取较小值即可。

当然后一步实际上可以用KMP实现，将s_1和s_2接上我们就可以很快知道某一段是否有s_3,这样可以二分验证
即二分[sa[i],sa[i]+height[i]-len(s3)]中s3出现的最靠前的位置pos。然后对pos-sa[i]+1+len(s3)-2取min，再去更新答案。
然后KMP你甚至可以写hash