这题真的太秀了。
如果我们能处理出每个围栏区间内有多少个贡献点，那么我们只需要倒序移走围栏，用DSU或者dp维护贡献就可以得到最后答案。
我们考虑将所有节点按y从大到小排序，那么如果我们遇到一个围栏节点，等价于在x这个位置插入一个节点，
而遇到一个贡献点，等价于在x这个位置后面找一个最近的围栏节点。
因此这个东西可以用splay来维护。

接下来如果我们只考虑两个点(x,y,t1)(a,b,t2)，其中x<a,y>b，那么会有两种围栏的情况。
若t1<t2，则我们遇到(a,b,t2)时仍然会在splay保留(x,y,t1)；
若t2>t1，则接下来，我们遇到的所有贡献点不会对(x,y,t1)产生贡献，因此可以删去这个点。

这是遇到围栏点的情况，遇到贡献点的话我们直接在splay中找到x比它大的第一个围栏点即可。
最后的DSU和dp维护要注意合并的顺序，是大的t往小的t进行合并。

