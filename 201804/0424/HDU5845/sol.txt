有一个很显然的 O(N^2)的dp做法
dp[i]表示到 i为止最多能分成多少段，然后从前面最多 L个 dp值转移出来，
但是对前面 L个 dp可以用 xor-trie维护一下，这样一来时间复杂度就是 O(Nlog(A))

每次将当前位置的前缀异或和插入trie，
并且在叶子节点维护一下当前位置的 dp值，其他节点维护出子树的 dp最大值做到 i的时候，
在 trie树上沿着异或等于 X的路径走而小于 X的路径可以直接用已经维护好的最大值
长度超过 L的部分需要删掉，而trie树不好直接删除，所以只需将dp值标记成 -1即可
由于 dp肯定是递增的，所以后来的值肯定更优，所以前缀异或和相同的只需要保存最后一个即可