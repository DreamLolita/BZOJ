典型的点分治题目。
对树进行点分治，对于每个分治结构，从重心开始 BFS 预处理出一个序列，满足序列中所有点到重心的距离依次递增。
那么每次从堆中取出$x$后，枚举$O(logn)$个经过它的分治结构， 不断更新序列首部的点的最短路，并把更新过的点删除，直到树上距离超过$lim_x$为止。 
因为每个点只被$O(logn)$个分治结构经过，故总时间复杂度为$O(nlogn)$。

设$dis_x$表示从$S$到$x$的最小代价$w_x=dis_x+cost_x$，
考虑最短路的$Dijkstra$算法，每次从堆中取出$w$最小的$x$，然后更新与$x$距离不超过$lim_x$的所有点即可。 
注意到$Dijkstra$算法中每次取出的$w$单调不下降，故每个点只有第一次被更新时才是最短路，这说明一个点访问过就可以不再考虑它。 
对树进行点分治，对于每个分治结构，从重心开始 BFS 预处理出一个序列，满足序列中所有点到重心的距离依次递增。
那么每次从堆中取出$x$后，枚举$O(logn)$个经过它的分治结构， 不断更新序列首部的点的最短路，并把更新过的点删除，直到树上距离超过$lim_x$为止。 
因为每个点只被$O(logn)$个分治结构经过，故总时间复杂度为$O(nlogn)$。
