题意：
一颗$n$个节点的树。
找三个不同编号的节点，使它们两两间距离相同（一条边距离视作1），求方案数。

难度加大以后就变神了啊qwq。%%%题解。
居然是用指针来$O(1)$转移。。。以下来自dalao的bloghttp://blog.csdn.net/neither_nor/article/details/51278993。

我们考虑一下dp，$f[i][j]$表示以$i$为根的子树里与$i$距离为$j$的点的个数，$g[i][j]$表示子树内有$g[i][j]$对点深度相同，且距离他们的$LCA$距离都为$d$，且$i$与他们的$LCA$的距离为$d-j$。换一种说法是表示以$i$为根的子树里有这么多个点对在底下分叉了，并且还没有第三个点和这个点对匹配，这个第3个点不在$i$的子树里并且与$i$距离为$j$的方案数（不考虑第三个点有多少种选法）

设$x$表示当前点，$y$表示儿子，则$f[x][0]=1,ans+=g[x][0]$

这样的话枚举出边，一边枚举一边更新保证不重复计算，每次枚举出边的时候再枚举$i$
$$f[x][i]+=f[y][i-1]$$
$$g[x][i-1]+=g[y][i]$$
$$g[x][i+1]+=f[x][i+1]*f[y][i]$$
$$ans+=f[x][i-1]*g[y][i]+g[x][i+1]*f[y][i]$$

但是这样的话时间和空间都会爆，我们把整个树进行轻重链剖分，子树深度最大的儿子是重儿子，重边练成重链，对于一个点，在第一次用儿子更新的时候我们有$f[x][i]=f[y][i-1]，g[x][i]=g[y][i+1]$，可以用指针$O(1)$进行这一步转移，由于对一个儿子进行转移的复杂度是$O(dep[y])$，所以不妨对重儿子进行$O(1)$转移

这个时间复杂度是$O(n)$的，证明如下：

设$h[x]$表示以$x$为根的子树的高度
对每个点转移的复杂度为$\sum (h[y]-h[son[x]])=\sum(h[y] -h[x]+1)$，做和的话除了叶子节点所有点的$dep$都被抵消，所以复杂度为$O(n)$
空间的话非叶子节点所需要的空间都是由他所在重链的叶子节点用指针挪过来的，所以对每个叶子节店给他开正比于所在重链长度的空间即可
空间复杂度为$O(\sum 重链长度和)=O(n)$
