啊，一看就是树形dp什么的。
对每个节点记录两个值，一个是从这个节点下去遍历所有子节点之后再回来所需要花费的时间，另一个是假设从0时刻开始到达这个点并接下来遍历这个子树，安装完成的时间的最大值最小是多少
然后转移时我们可以贪心得排一个序，然后按顺序走完这些子树，直接算出父节点的值
不妨设$t_i$为从$i$开始遍历一圈回来的时间，$b_i$为这颗子树最大值的最小值
然后子树$i$排在$j$前面当且仅当$max(1+b_i,3+t_i+b_j)<max(1+b_j,3+t_j+b_i)$