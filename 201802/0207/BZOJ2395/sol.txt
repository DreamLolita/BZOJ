假装自己学了一波东西：最小乘积生成树。
以下转自：http://blog.csdn.net/vmurder/article/details/46828379

###最小乘积生成树定义

有一张$n$个点$m$条边的无向图，每条边有$k$个权值。
现在要取一个边集M使得其将所有点连通，并使
$\prod_{i=1}^k (\sum_j^{j\in M} cost(j,{val_i}) )$最小
即个边集的每一种边权的总和的乘积最小。

比如：
$k=1$时，就是裸最小生成树。
$k=2$时，就是要使 [边集的权值1的和]*[边集的权值2的和] 最小。

###最小乘积生成树的一种求法：
广义上的说法：
首先我们可以把每种生成树想成一个$k$维的点，第$i$维的坐标即那一维上权值的和。
然后我们可以先求出每一维坐标最小的一棵生成树（裸上最小生成树就好），
然后得到一个$k-1$维的面，然后我们来求一下离这个面最远的点，然后分治下去……据说期望很快……

###二维最小乘积生成树的求法：
给每一棵生成树都定义两个权值$X、Y$，其中$X$为其包含的所有边的权值$x$的和，$Y$为其包含的所有边的权值$y$的和，那么我们可以把每一种生成树看成一个坐标。
我们先求出坐标$x$最小的一棵生成树，再求出坐标$y$最小的一棵生成树。
然后我们可以考虑，最优的点一定在下凸包上【证明一】，然后我们要进行一个不断向左下拓展点的过程：对于两个点$A、B$形成的直线，我们可以找出在这条直线左下的最远的点$C$，然后对$AC、CB$递归做同样的过程，直到找不到一个在左下的点$C$为止。

然后如何找一个最远的点C呢？――由于C离AB最远，所以S△ABC面积最大。就是让$\vec{AB}\times\vec{AC}$最小
$$\begin{align} \vec{AB}\times\vec{AC}& =(B.x-A.x)*(C.y-A.y)-(B.y-A.y)*(C.x-A.x)\\ & =C.x*(A.y-B.y)+C.y*(B.x-A.x)+(...) \end{align}$$
$(...)$是只与$A,B$有关的量，可以看做常数。
因此我们将所有边权设为$a[k].x*(A.y-B.y)+a[k].y*(B.x-A.x)$，然后求最小生成树就行了。
边界$\vec{AB}\times\vec{AC}\ge0$

【证明一】
每个点$(x_i,y_i)$ 都对应一条函数曲线 $k_i=x_i?y_i$，而任意两不同 $k_i$ ，它们的函数曲线是不交的（有交的话则存在一点 $(x_j,y_j)$ 使得 $k_i=x_j?y_j=k_j$而$k_i!=k_j$ 成立，显然这是悖论），那么显然最优点肯定不会在凸包内，否则必有凸包上一点比它优。
那么会不会求出这个某种意义上的凸包后，最优点在凸包外，却没被找到呢？
不会。
若有这种情况，此点必然在凸包上某边的左下方，然后一定会被找出来。。