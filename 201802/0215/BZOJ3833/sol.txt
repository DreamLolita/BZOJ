首先第一眼看上去像计算几何qwq，不过因为所有灯朝向一样，所以我们转一下坐标轴就行了。
我们把$(x_i,y_i)$变成$(a_i,b_i)$使得
$$a_i \times x_1 + b_i \times x_2 = x_i \\ a_i \times y_1 + b_i \times y_2 = y_i$$
然后可以得到：
$$a_i = \frac{x_i \times y_2 - y_i \times x_2}{x_1 \times y_2 - x_2 \times y_1} \\
b_i = \frac{x_i \times y_1 - y_i \times x_1}{x_1 \times y_2 - x_2 \times y_1}$$

这些坐标分母一样，所以可以丢掉。
转化问题后，我们发现这就是就是按顺序查询一个点左下角的区域内第$k_i$小的数是多少（记为$t$）。
然后有$ans_i=min(i,t)$，特别地，如果没有$k_i$个灯泡，$ans_i=i$。

考虑怎么维护这个东西？

我们可以写树套树维护一下插入操作，以往都是要二分然后再查询的，这样时间复杂度是$O(log^3n)$的，显然不可以接受....
但是这题只需要查$k$大，所以我们可以反过来，以$ans$为第一关键字建线段树，然后对$a$坐标建平衡树，这样就可以省去二分了。
~~想用带修主席树？不好意思卡内存呢。~~

查询操作我们就可以二分答案了。
具体做法就是从线段树根结点开始，先看左儿子所套的平衡树里边$a$坐标小于等于$a_i$的结点个数。
设有$u$个，如果$u\geq k[i]$，说明答案应该在$[l,mid]$之间，然后递归处理。
否则答案就应该在$[mid+1,r]$之间，然后递归处理。
直到$l=r$的时候，便可确定$ans[i]=min(i,l)$。
查询操作中，我们要访问$O(logn)$个线段树结点，在每个线段树节点中，都要$O(logn)$地查找相关点的个数。
所以查询操作的时间复杂度也是$O(log^2n)$的。

然后有$O(n)$个灯泡，所以总时间复杂度是$O(nlog^2n)$的。
每个灯泡的信息会被插入到$O(logn)$个线段树所套的平衡树里，
所以空间复杂度是$O(nlogn)$的。

以上，太麻烦了，我不想写。对于我来说，正确的操作姿势应该是整体二分。

直接二分时间$[L,R]$同时$[l,r]$为在此段时间内点亮的灯，取Mid=\frac {L+R} 2$，
将$[l,r]$划分为$[l,mid]$与$[mid+1,r]$表示在$Mid$前点亮的灯与在Mid后点亮的灯，递归求解即可。

那么现在问题是如何求一盏灯是否在$Mid$前点亮，关键在于求一盏灯的左下角的灯的数目。
我们直接用扫描线做就行了：将灯按照$x$坐标排序，用树状数组维护$y$坐标，横向依次扫描就可以完成了。
如果求得的左下角的灯的个数大于等于$k$个，或者灯的编号大于等于$Mid$，则把它归到$[l,mid]$的区间。

然后就是这样，写分治不仅代码简单，而且常数小，何乐而不为呢？
~~（AC时速度第4，代码2kb，写数据结构的话速度和代码量都是两倍左右）~~
~~强烈鄙视这种文末一定要带换行符的PE!!!~~